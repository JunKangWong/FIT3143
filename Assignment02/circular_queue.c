/* Members:     Name: Chan Kah Hee     Email: kcha0047@student.monash.edu
 *              Name: Wong Jun Kang    Email: jwon0050@student.monash.edu
 * Team: Team-07
 * Lab:  MA_LAB-06 
 * Lecturer:    Dr Vishnu Monn Baskaran
 * Tutor:       Mr Lee Ming Jie 
 * 
 * Implementation of queue that stores recent information generated by a 
 * sensor node. Onces the queue gets full the oldest results will get 
 * replaced when new result comes in.   */

/* header files */
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdarg.h> // for variadic func
#include "sensor_node.h"
#include "circular_queue.h"


queue_t *init_queue(element_type_t element_type){
    /* This function initialises a circular queue. Given the element type 
     * SENSOR_NODE and SWC_HEIGHT, it will initialise the corresponding queue 
     * for the element type.
     *
     * args:    element_type    -   element type enum for mode selection. 
     * 
     * return:  q   -   an initialised queue  */
    queue_t *q = malloc(sizeof(queue_t));   // allocate memory for queue_t
    
    // if memory allocation has no error
    if (q != NULL) {
        q->element_type = element_type;
        q->rear = -1;
        q->size = 0;
        switch (element_type) {
            case SENSOR_NODE:
            {
                break;
            }
            
            case SWC_HEIGHT:
            {
                q->array.swc_heights = malloc(sizeof(swc_height_t) * QUEUE_CAPACITY);
                break;
            }
        }
    }
    return q;
}


bool is_empty(queue_t *q){
    /* This function checks if the queue is empty.
     *
     * args:    q   - the queue object which the size is to be checked.
     * 
     * return: true if the queue is empty else false */
    return q->size == 0;
}


bool is_full(queue_t *q){
    /*
     * This function is used to check if the queue is full.
     *
     * args:    q   -   the queue which the size is to be checked.
     * 
     * return: true if the queue is full else false     */
    return q->size >= QUEUE_CAPACITY;
}

void enqueue(queue_t *q, ...) {
    /* This function enqueues either a double or a swc_height_t 
     * (sea water column height reading structure) into a queue.
     *
     * args:    q   -   the queue to perform enqueue
     * 
     * return:   */
    va_list lst;    // declare type for iterating args
    va_start (lst, q);  // start iterating args
    
    switch (q->element_type) {
        case SENSOR_NODE:
        { 
            q->rear = (++q->rear) % QUEUE_CAPACITY;
            q->array.sensor_heights[q->rear] = va_arg(lst, double);
            break;
        }
        
        case SWC_HEIGHT:
        {
            q->rear = (++q->rear) % QUEUE_CAPACITY;
            q->array.swc_heights[q->rear] = va_arg(lst, swc_height_t);
            break;
        }
    }
    
    va_end(lst);    // clean up
    q->size++;
}


float calc_simple_moving_avg(queue_t *q) {
    /* Calculates simple moving average based on a given queue with SENSOR_NODE
     * as element type. This function will only calculate simple moving 
     * average for queue that is full.
     *
     * args:    q   -   the queue used to calculate the simple moving average
     * 
     * return:  simple_moving_avg   -   simple moving average    */
    if (q->element_type != SENSOR_NODE) {
        perror("swc_height_t cannot calculate simple moving average!");
        exit(1);
    }
    
    float sum = 0.0f;
    float simple_moving_avg = 0.0f;
    
    if(is_full(q)){
        // sum all recorded height
        for(int i = 0; i < QUEUE_CAPACITY; i++) {
            sum += q->array.sensor_heights[i];
        }
        simple_moving_avg = sum / QUEUE_CAPACITY;
    }
    return simple_moving_avg;
}

void delete_queue(queue_t *q) {
    /* Given a queue, this function frees up memory of the queue.
     *
     * args:    q   -   the queue to be freed
     * 
     * return:   */
    switch (q->element_type) {
        case SENSOR_NODE:
        {
            break;
        }
        
        case SWC_HEIGHT:
        {
            free(q->array.swc_heights);
            break;
        }
    }
    free(q);
}
